# Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계

## 기본과제: 거대 단일 컴포넌트 리팩토링

이번 과제는 단일책임원칙을 위반한 거대한 컴포넌트를 리팩토링 하는 것입니다. React의 컴포넌트는 단일 책임 원칙(Single Responsibility Principle, SRP)을 따르는 것이 좋습니다. 즉, 각 컴포넌트는 하나의 책임만을 가져야 합니다. 하지만 실제로는 여러 가지 기능을 가진 거대한 컴포넌트를 작성하는 경우가 많습니다.

[목표]
## 1. 취지
- React의 추구미(!)를 이해해보아요!
- 단일 책임 원칙(SRP)을 위반한 거대한 컴포넌트가 얼마나 안 좋은지 경험해보아요!
- 단일 책임이라는 개념을 이해하기 상태, 순수함수, 컴포넌트, 훅 등 다양한 계층을 이해해합니다.
- 엔티티와 UI를 구분하고 데이터, 상태, 비즈니스 로직 등의 특징이 다르다는 것을 이해해보세요.
- 이를 통해 적절한 Custom Hook과 유틸리티 함수를 분리하고, 컴포넌트 계층 구조를 정리하는 능력을 갖춥니다!


## 2. 목표

모든 소프트웨어에는 적절한 책임과 계층이 존재합니다. 하나의 계층(Component)만으로 소프트웨어를 구성하게 되면 나중에는 정리정돈이 되지 않은 코드를 만나게 됩니다. 예전에는 이러한 BestPractice에 대해서 혼돈의 시대였지만 FE가 진화를 거듭하는 과정에서 적절한 계측에 대한 합의가 이루어지고 있는 상태입니다.

React의 주요 책임 계층은 Component, hook, function 등이 있습니다. 그리고 주요 분류 기준은 **엔티티**가 되어 줍니다.

- 엔티티를 다루는 상태와 그렇지 않은 상태 - cart, isCartFull vs isShowPopup
- 엔티티를 다루는 컴포넌트와 훅 - CartItemView, useCart(), useProduct()
- 엔티티를 다루지 않는 컴포넌트와 훅 - Button, useRoute, useEvent 등
- 엔티티를 다루는 함수와 그렇지 않은 함수 - calculateCartTotal(cart)  vs capaitalize(str)

이번 과제의 목표는 이러한 계층을 이해하고 분리하여 정리정돈을 하는 기준이나 방법등을 습득하는데 있습니다.

제시된 코드는 각각의 컴포넌트에 모든 비즈니스 로직이 작성되어 있습니다. 여기에서 custom hook과 util 함수를 적절하게 분리하고, **테스트 코드를 통과할 수 있도록 해주세요.**

> basic의 경우 상태관리를 쓰지 않고 작업을 해주세요.

### (1) 요구사항

#### 1) 장바구니 페이지 요구사항

- 상품 목록
    - 상품명, 가격, 재고 수량 등을 표시
    - 각 상품의 할인 정보 표시
    - 재고가 없는 경우 품절 표시가 되며 장바구니 추가가 불가능
- 장바구니
    - 장바구니 내 상품 수량 조절 가능
    - 각 상품의 이름, 가격, 수량과 적용된 할인율을 표시
        - 적용된 할인율 표시 (예: "10% 할인 적용")
    - 장바구니 내 모든 상품의 총액을 계산해야
- 쿠폰 할인
    - 할인 쿠폰을 선택하면 적용하면 최종 결제 금액에 할인정보가 반영
- 주문요약
    - 할인 전 총 금액
    - 총 할인 금액
    - 최종 결제 금액

#### 2) 관리자 페이지 요구사항

- 상품 관리
    - 상품 정보 (상품명, 가격, 재고, 할인율) 수정 가능
    - 새로운 상품 추가 가능
    - 상품 제거 가능
- 할인 관리
    - 상품별 할인 정보 추가/수정/삭제 가능
    - 할인 조건 설정 (구매 수량에 따른 할인율)
- 쿠폰 관리
    - 전체 상품에 적용 가능한 쿠폰 생성
    - 쿠폰 정보 입력 (이름, 코드, 할인 유형, 할인 값)
    - 할인 유형은 금액 또는 비율로 설정 가능

### (2) 코드 개선 요구사항

#### 1) cart, product에 대한 계산 함수 분리

- calculateItemTotal
- getMaxApplicableDiscount
- calculateCartTotal
- updateCartItemQuantity

#### 2) 상태를 다루는 hook, 유틸리티 hook 분리

- useCart
- useCoupon
- useProduct
- useLocalStorage

#### 3) 엔티티 컴포넌트와 UI 컴포넌트 분리하여 계층구조 만들기

- ProductCard
- Cart
- …

### (3) 테스트 코드 통과하기



## 심화과제: Props drilling
> **이번 심화과제는 Props drilling을 없애기 입니다.**

# 2. 목표

- basic에서 열심히 컴포넌트를 분리해주었겠죠?
- 아마 그 과정에서 container - presenter 패턴으로 만들어졌기에 props drilling이 상당히 불편했을거에요.
- 그래서 심화과제에서는 props drilling을 제거하는 작업을 할거에요.
    - 전역상태관리가 아직 낯설다. - jotai를 선택해주세요 (참고자료 참고)
    - 나는 React만으로 해보고 싶다. - context를 선택해서 상태관리를 해보세요.
    - 나는 지금 대세인 Zustand를 할거에요. - zustand를 선택해주세요.


### (1) 요구사항

- 불필요한 props를 제거하고, 필요한 props만을 전달하도록 개선합니다.
- Context나 Jotai 혹은 Zustand를 사용하여 상태를 관리합니다.
- 테스트 코드를 통과합니다.

### 기본과제

- Component에서 비즈니스 로직을 분리하기
- 비즈니스 로직에서 특정 엔티티만 다루는 계산을 분리하기
- 뷰데이터와 엔티티데이터의 분리에 대한 이해
- entities -> features -> UI 계층에 대한 이해

- [x] Component에서 사용되는 Data가 아닌 로직들은 hook으로 옮겨졌나요?
- [x] 주어진 hook의 책임에 맞도록 코드가 분리가 되었나요?
- [x] 계산함수는 순수함수로 작성이 되었나요?
- [x] Component에서 사용되는 Data가 아닌 로직들은 hook으로 옮겨졌나요?
- [x] 주어진 hook의 책임에 맞도록 코드가 분리가 되었나요?
- [x] 계산함수는 순수함수로 작성이 되었나요?
- [x] 특정 Entitiy만 다루는 함수는 분리되어 있나요?
- [x] 특정 Entitiy만 다루는 Component와 UI를 다루는 Component는 분리되어 있나요?
- [x] 데이터 흐름에 맞는 계층구조를 이루고 의존성이 맞게 작성이 되었나요?

### 심화과제

- 이번 심화과제는 Context나 Jotai를 사용해서 Props drilling을 없애는 것입니다.
- 어떤 props는 남겨야 하는지, 어떤 props는 제거해야 하는지에 대한 기준을 세워보세요.
- Context나 Jotai를 사용하여 상태를 관리하는 방법을 익히고, 이를 통해 컴포넌트 간의 데이터 전달을 효율적으로 처리할 수 있습니다.

- [x] Context나 Jotai를 사용해서 전역상태관리를 구축했나요?
- [x] 전역상태관리를 통해 domain custom hook을 적절하게 리팩토링 했나요?
- [x] 도메인 컴포넌트에 도메인 props는 남기고 props drilling을 유발하는 불필요한 props는 잘 제거했나요?
- [x] 전체적으로 분리와 재조립이 더 수월해진 결합도가 낮아진 코드가 되었나요?

## 과제 셀프회고

### 과제를 하면서 내가 알게된 점, 좋았던 점은 무엇인가요?

이번 과제를 진행하면서 “순수 함수 중심의 구조”가 테스트 가능성과 유지보수성에 얼마나 큰 영향을 주는지 체감했습니다. 입력과 출력이 명확한 형태로 구성하니 로직 검증이 쉬워졌고, 부수효과가 필요한 부분은 뒤쪽에서 한 번에 처리하는 흐름으로 정리되면서 코드가 한결 안정적으로 보였습니다.
컴포넌트끼리 props drilling이 많아지기 쉬운 구조였는데, 특정 도메인 단위로 props를 묶어 전달하는 방식으로 정리하다 보니 컴포넌트 응집도가 높아지고 사용성도 좋아졌습니다. 특히 Selector 컴포넌트는 구조가 깔끔하게 잡혀서 만족스럽게 완성할 수 있었습니다.

또한 장바구니 로직을 구현하면서 useMemo를 적절히 사용해 사전에 계산된 데이터를 넘겨주는 방식(예: filledItems)이 렌더링 비용을 확실히 줄여준다는 것도 배웠습니다. 특정 엔티티에 강하게 묶인 로직을 유틸 함수나 커스텀 훅으로 분리하는 기준도 자연스럽게 익힐 수 있었고, 클린 코드의 핵심이 “언제든 깔끔하게 지울 수 있을 정도로 단순하고 응집도 높은 구조”라는 점을 다시 확인할 수 있었습니다.

### 이번 과제에서 내가 제일 신경 쓴 부분은 무엇인가요?

가능한 한 순수 함수 형태로 로직을 구성하고, 컴포넌트가 너무 많은 책임을 지지 않도록 계층을 나누는 데 가장 많은 신경을 썼습니다.
특히 ProductList → ProductItem에서 발생하는 props drilling 문제를 줄이기 위해 구조를 고민했고, 기존 Header처럼 지나치게 분리하기보다 필요한 정보를 각 도메인 단위로 묶어서 전달하는 방식으로 정리해 불필요한 의존을 줄였습니다.
또한 각 기능에서 전달되는 시그니처 함수들이 최소한의 역할만 가지도록 구조를 단순화했고, 전역 상태는 Zustand를 이용해 관리하며 불필요한 상태 전달을 최소화했습니다. 다만 Zustand를 도입하면서 아직 충분히 숙련되지 못해 상태 설계나 분리 기준을 더 깔끔하게 잡지 못한 아쉬움도 있었습니다.

상태 변경은 가능한 뒤쪽에서 한 번에 처리하도록 흐름을 잡았고, 재계산 비용이 많은 장바구니 영역은 useMemo로 선계산한 데이터를 내려 렌더링 성능을 신경 썼습니다. 전역적으로 사용될 가능성이 있는 가격 표시 함수(getDisplayPrice)도 분리해야겠다는 필요성을 느꼈고, 앞으로 개선할 예정입니다.

### 이번 과제를 통해 앞으로 해보고 싶은게 있다면 알려주세요!

도메인별로 로직을 더 정교하게 분리하고, 공통으로 사용할 수 있는 유틸 함수 모음이나 테이블 컴포넌트 같은 공통 모듈을 직접 설계해 보고 싶습니다. 또 전역 상태 관리자로 Zustand를 도입해보면서 전반적인 흐름을 이해하게 되었기 때문에, 앞으로는 더 복잡한 상태 구조도 설계해보고 싶습니다.
추후에는 가격 계산, 할인 처리와 같은 반복되는 로직을 전역 레벨에서 재사용할 수 있도록 정리해 안정적인 구조를 계속 넓혀가보고 싶습니다.
