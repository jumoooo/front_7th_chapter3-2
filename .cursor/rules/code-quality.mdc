# 코드 품질 규칙

## 📋 코드 작성 원칙

### 1. 타입 안정성
- TypeScript 타입 정의 명확히
- `any` 타입 사용 최소화
- 타입 오류는 반드시 해결
- 인터페이스와 타입 별칭 적절히 활용

### 2. 함수형 프로그래밍
- 순수 함수 우선 사용
- 사이드 이펙트 최소화
- 불변성 유지
- 액션과 순수 함수 분리

### 3. 관심사 분리
- 단일 책임 원칙 준수
- 컴포넌트는 UI만 담당
- 비즈니스 로직은 Hook으로 분리
- 계산 로직은 순수 함수로 분리

---

## 🏗️ 아키텍처 규칙

### 1. 계층 구조
```
entities/ (domain/)
  └─ 순수 함수 (계산 로직)

features/ (hooks/ 또는 stores/)
  └─ Entity Hook 또는 Store

ui/ (components/, pages/)
  └─ UI 컴포넌트
```

### 2. 의존성 방향
- entities <- features <- ui
- 하위 계층은 상위 계층에 의존하지 않음
- 순환 의존성 방지

### 3. Entity 분리
- 특정 Entity만 다루는 함수는 분리
- Entity를 다루는 Hook과 UI Hook 구분
- Entity 상태와 UI 상태 구분

---

## 🔧 React 규칙

### 1. Hook 사용
- Custom Hook으로 비즈니스 로직 분리
- Hook의 책임 명확히
- 의존성 배열 정확히 관리
- 불필요한 재렌더링 방지

### 2. 상태 관리
- Entity 상태와 UI 상태 구분
- 함수형 업데이트 패턴 사용 (필요시)
- localStorage 동기화 적절히 처리
- 상태 업데이트 배치 처리 고려

### 3. 컴포넌트 설계
- 재사용 가능한 컴포넌트 설계
- Props 타입 명확히 정의
- 조건부 렌더링 적절히 사용
- 불필요한 props 전달 방지

---

## 📦 파일 구조 규칙

### 1. 폴더 구조
- 기능별로 폴더 분리
- 관련 파일은 같은 폴더에 배치
- 계층 구조 명확히

### 2. 파일 명명
- 컴포넌트: PascalCase (예: `ProductList.tsx`)
- Hook: camelCase with `use` prefix (예: `useProduct.ts`)
- 유틸리티: camelCase (예: `cartUtils.ts`)
- 타입: camelCase (예: `productTypes.ts`)

### 3. Import 순서
1. React 및 외부 라이브러리
2. 타입 정의
3. 도메인 로직 (순수 함수)
4. Hook
5. 컴포넌트
6. 상대 경로 import

---

## 🎨 코드 스타일

### 1. 가독성
- 의미 있는 변수명 사용
- 복잡한 로직은 주석 추가
- 함수는 작고 명확하게
- 중첩 깊이 최소화

### 2. 일관성
- 프로젝트 내 코딩 스타일 일관성 유지
- 기존 코드 스타일 따라가기
- 팀 컨벤션 준수

### 3. 최적화
- 불필요한 재렌더링 방지
- useMemo, useCallback 적절히 사용
- 큰 리스트는 가상화 고려
- 메모이제이션 전략 수립

---

## ⚠️ 금지 사항

### 1. 절대 하지 말아야 할 것
- 테스트 코드 수정
- 기존 기능 동작 변경
- 타입 안정성 무시
- 순환 의존성 생성

### 2. 지양해야 할 것
- 과도한 중첩
- 긴 함수 (50줄 이상)
- 복잡한 조건문
- 하드코딩된 값

---

## ✅ 코드 리뷰 체크리스트

작성한 코드 확인:
- [ ] 타입 오류 없음
- [ ] 린터 오류 없음
- [ ] 테스트 통과
- [ ] 기존 기능 정상 동작
- [ ] 코드 가독성 양호
- [ ] 성능 이슈 없음
- [ ] 보안 이슈 없음
